//ENTRY Program
//Program.main(arrayOf())
@Suppress("MemberVisibilityCanBePrivate", "FunctionName", "CanBeVal", "DoubleNegation", "LocalVariableName", "NAME_SHADOWING", "VARIABLE_WITH_REDUNDANT_INITIALIZER", "RemoveRedundantCallsOfConversionMethods", "EXPERIMENTAL_IS_NOT_ENABLED", "RedundantExplicitType", "RemoveExplicitTypeArguments", "RedundantExplicitType", "unused", "UNCHECKED_CAST", "UNUSED_VARIABLE", "UNUSED_PARAMETER", "NOTHING_TO_INLINE", "PropertyName", "ClassName", "USELESS_CAST", "PrivatePropertyName", "CanBeParameter", "UnusedMainParameter")
@UseExperimental(ExperimentalUnsignedTypes::class)
class Program(HEAP_SIZE: Int = 0) : Runtime(HEAP_SIZE) {
	// typealias uint8_t = UByte
	// typealias uint16_t = UShort
	// typealias bs_t = bs_t
	// typealias L12_scale_info = L12_scale_info
	// typealias L12_subband_alloc_t = L12_subband_alloc_t
	// typealias L3_gr_info_t = L3_gr_info_t
	// typealias mp3dec_scratch_t = mp3dec_scratch_t
	
	//////////////////
	// C STRUCTURES //
	//////////////////
	
	/*!inline*/ class bs_t(val ptr: Int) : IStruct {
		companion object : IStructCompanion<bs_t>  {
			const val SIZE_BYTES = 12
			override val SIZE = SIZE_BYTES
			const val OFFSET_buf = 0
			const val OFFSET_pos = 4
			const val OFFSET_limit = 8
		}
	}
	fun bs_tAlloc(): bs_t = bs_t(alloca(bs_t.SIZE_BYTES).ptr)
	fun bs_tAlloc(buf: CPointer<UByte>, pos: Int, limit: Int): bs_t = bs_tAlloc().apply { this.buf = buf; this.pos = pos; this.limit = limit }
	fun bs_t.copyFrom(src: bs_t): bs_t = this.apply { memcpy(CPointer<Unit>(this.ptr), CPointer<Unit>(src.ptr), bs_t.SIZE_BYTES) }
	fun fixedArrayOfbs_t(size: Int, vararg items: bs_t): CPointer<bs_t> = alloca_zero(size * bs_t.SIZE_BYTES).toCPointer<bs_t>().also { for (n in 0 until items.size) bs_t(it.ptr + n * bs_t.SIZE_BYTES).copyFrom(items[n]) }
	operator fun CPointer<bs_t>.get(index: Int): bs_t = bs_t(this.ptr + index * bs_t.SIZE_BYTES)
	operator fun CPointer<bs_t>.set(index: Int, value: bs_t) = bs_t(this.ptr + index * bs_t.SIZE_BYTES).copyFrom(value)
	@kotlin.jvm.JvmName("plusbs_t") operator fun CPointer<bs_t>.plus(offset: Int): CPointer<bs_t> = CPointer(this.ptr + offset * bs_t.SIZE_BYTES)
	@kotlin.jvm.JvmName("minusbs_t") operator fun CPointer<bs_t>.minus(offset: Int): CPointer<bs_t> = CPointer(this.ptr - offset * bs_t.SIZE_BYTES)
	@kotlin.jvm.JvmName("minusPtrbs_t") operator fun CPointer<bs_t>.minus(other: CPointer<bs_t>) = (this.ptr - other.ptr) / bs_t.SIZE_BYTES
	var CPointer<bs_t>.value: bs_t get() = this[0]; set(value) = run { this[0] = value }
	var bs_t.buf: CPointer<UByte> get() = CPointer(lw(ptr + bs_t.OFFSET_buf)); set(value) = run { sw(ptr + bs_t.OFFSET_buf, value.ptr) }
	var bs_t.pos: Int get() = lw(ptr + bs_t.OFFSET_pos); set(value) = sw(ptr + bs_t.OFFSET_pos, value)
	var bs_t.limit: Int get() = lw(ptr + bs_t.OFFSET_limit); set(value) = sw(ptr + bs_t.OFFSET_limit, value)
	/*!inline*/ class L12_scale_info(val ptr: Int) : IStruct {
		companion object : IStructCompanion<L12_scale_info>  {
			const val SIZE_BYTES = 898
			override val SIZE = SIZE_BYTES
			const val OFFSET_scf = 0
			const val OFFSET_total_bands = 768
			const val OFFSET_stereo_bands = 769
			const val OFFSET_bitalloc = 770
			const val OFFSET_scfcod = 834
		}
	}
	fun L12_scale_infoAlloc(): L12_scale_info = L12_scale_info(alloca(L12_scale_info.SIZE_BYTES).ptr)
	fun L12_scale_infoAlloc(scf: Array192Float, total_bands: UByte, stereo_bands: UByte, bitalloc: Array64UByte, scfcod: Array64UByte): L12_scale_info = L12_scale_infoAlloc().apply { this.scf = scf; this.total_bands = total_bands; this.stereo_bands = stereo_bands; this.bitalloc = bitalloc; this.scfcod = scfcod }
	fun L12_scale_info.copyFrom(src: L12_scale_info): L12_scale_info = this.apply { memcpy(CPointer<Unit>(this.ptr), CPointer<Unit>(src.ptr), L12_scale_info.SIZE_BYTES) }
	fun fixedArrayOfL12_scale_info(size: Int, vararg items: L12_scale_info): CPointer<L12_scale_info> = alloca_zero(size * L12_scale_info.SIZE_BYTES).toCPointer<L12_scale_info>().also { for (n in 0 until items.size) L12_scale_info(it.ptr + n * L12_scale_info.SIZE_BYTES).copyFrom(items[n]) }
	operator fun CPointer<L12_scale_info>.get(index: Int): L12_scale_info = L12_scale_info(this.ptr + index * L12_scale_info.SIZE_BYTES)
	operator fun CPointer<L12_scale_info>.set(index: Int, value: L12_scale_info) = L12_scale_info(this.ptr + index * L12_scale_info.SIZE_BYTES).copyFrom(value)
	@kotlin.jvm.JvmName("plusL12_scale_info") operator fun CPointer<L12_scale_info>.plus(offset: Int): CPointer<L12_scale_info> = CPointer(this.ptr + offset * L12_scale_info.SIZE_BYTES)
	@kotlin.jvm.JvmName("minusL12_scale_info") operator fun CPointer<L12_scale_info>.minus(offset: Int): CPointer<L12_scale_info> = CPointer(this.ptr - offset * L12_scale_info.SIZE_BYTES)
	@kotlin.jvm.JvmName("minusPtrL12_scale_info") operator fun CPointer<L12_scale_info>.minus(other: CPointer<L12_scale_info>) = (this.ptr - other.ptr) / L12_scale_info.SIZE_BYTES
	var CPointer<L12_scale_info>.value: L12_scale_info get() = this[0]; set(value) = run { this[0] = value }
	var L12_scale_info.scf: Array192Float get() = Array192Float(ptr + L12_scale_info.OFFSET_scf); set(value) = run { TODO("Unsupported setting ftype=Float[192]") }
	var L12_scale_info.total_bands: UByte get() = lb(ptr + L12_scale_info.OFFSET_total_bands).toUByte(); set(value) = sb(ptr + L12_scale_info.OFFSET_total_bands, (value).toByte())
	var L12_scale_info.stereo_bands: UByte get() = lb(ptr + L12_scale_info.OFFSET_stereo_bands).toUByte(); set(value) = sb(ptr + L12_scale_info.OFFSET_stereo_bands, (value).toByte())
	var L12_scale_info.bitalloc: Array64UByte get() = Array64UByte(ptr + L12_scale_info.OFFSET_bitalloc); set(value) = run { TODO("Unsupported setting ftype=UByte[64]") }
	var L12_scale_info.scfcod: Array64UByte get() = Array64UByte(ptr + L12_scale_info.OFFSET_scfcod); set(value) = run { TODO("Unsupported setting ftype=UByte[64]") }
	/*!inline*/ class L12_subband_alloc_t(val ptr: Int) : IStruct {
		companion object : IStructCompanion<L12_subband_alloc_t>  {
			const val SIZE_BYTES = 3
			override val SIZE = SIZE_BYTES
			const val OFFSET_tab_offset = 0
			const val OFFSET_code_tab_width = 1
			const val OFFSET_band_count = 2
		}
	}
	fun L12_subband_alloc_tAlloc(): L12_subband_alloc_t = L12_subband_alloc_t(alloca(L12_subband_alloc_t.SIZE_BYTES).ptr)
	fun L12_subband_alloc_tAlloc(tab_offset: UByte, code_tab_width: UByte, band_count: UByte): L12_subband_alloc_t = L12_subband_alloc_tAlloc().apply { this.tab_offset = tab_offset; this.code_tab_width = code_tab_width; this.band_count = band_count }
	fun L12_subband_alloc_t.copyFrom(src: L12_subband_alloc_t): L12_subband_alloc_t = this.apply { memcpy(CPointer<Unit>(this.ptr), CPointer<Unit>(src.ptr), L12_subband_alloc_t.SIZE_BYTES) }
	fun fixedArrayOfL12_subband_alloc_t(size: Int, vararg items: L12_subband_alloc_t): CPointer<L12_subband_alloc_t> = alloca_zero(size * L12_subband_alloc_t.SIZE_BYTES).toCPointer<L12_subband_alloc_t>().also { for (n in 0 until items.size) L12_subband_alloc_t(it.ptr + n * L12_subband_alloc_t.SIZE_BYTES).copyFrom(items[n]) }
	operator fun CPointer<L12_subband_alloc_t>.get(index: Int): L12_subband_alloc_t = L12_subband_alloc_t(this.ptr + index * L12_subband_alloc_t.SIZE_BYTES)
	operator fun CPointer<L12_subband_alloc_t>.set(index: Int, value: L12_subband_alloc_t) = L12_subband_alloc_t(this.ptr + index * L12_subband_alloc_t.SIZE_BYTES).copyFrom(value)
	@kotlin.jvm.JvmName("plusL12_subband_alloc_t") operator fun CPointer<L12_subband_alloc_t>.plus(offset: Int): CPointer<L12_subband_alloc_t> = CPointer(this.ptr + offset * L12_subband_alloc_t.SIZE_BYTES)
	@kotlin.jvm.JvmName("minusL12_subband_alloc_t") operator fun CPointer<L12_subband_alloc_t>.minus(offset: Int): CPointer<L12_subband_alloc_t> = CPointer(this.ptr - offset * L12_subband_alloc_t.SIZE_BYTES)
	@kotlin.jvm.JvmName("minusPtrL12_subband_alloc_t") operator fun CPointer<L12_subband_alloc_t>.minus(other: CPointer<L12_subband_alloc_t>) = (this.ptr - other.ptr) / L12_subband_alloc_t.SIZE_BYTES
	var CPointer<L12_subband_alloc_t>.value: L12_subband_alloc_t get() = this[0]; set(value) = run { this[0] = value }
	var L12_subband_alloc_t.tab_offset: UByte get() = lb(ptr + L12_subband_alloc_t.OFFSET_tab_offset).toUByte(); set(value) = sb(ptr + L12_subband_alloc_t.OFFSET_tab_offset, (value).toByte())
	var L12_subband_alloc_t.code_tab_width: UByte get() = lb(ptr + L12_subband_alloc_t.OFFSET_code_tab_width).toUByte(); set(value) = sb(ptr + L12_subband_alloc_t.OFFSET_code_tab_width, (value).toByte())
	var L12_subband_alloc_t.band_count: UByte get() = lb(ptr + L12_subband_alloc_t.OFFSET_band_count).toUByte(); set(value) = sb(ptr + L12_subband_alloc_t.OFFSET_band_count, (value).toByte())
	/*!inline*/ class L3_gr_info_t(val ptr: Int) : IStruct {
		companion object : IStructCompanion<L3_gr_info_t>  {
			const val SIZE_BYTES = 28
			override val SIZE = SIZE_BYTES
			const val OFFSET_sfbtab = 0
			const val OFFSET_part_23_length = 4
			const val OFFSET_big_values = 6
			const val OFFSET_scalefac_compress = 8
			const val OFFSET_global_gain = 10
			const val OFFSET_block_type = 11
			const val OFFSET_mixed_block_flag = 12
			const val OFFSET_n_long_sfb = 13
			const val OFFSET_n_short_sfb = 14
			const val OFFSET_table_select = 15
			const val OFFSET_region_count = 18
			const val OFFSET_subblock_gain = 21
			const val OFFSET_preflag = 24
			const val OFFSET_scalefac_scale = 25
			const val OFFSET_count1_table = 26
			const val OFFSET_scfsi = 27
		}
	}
	fun L3_gr_info_tAlloc(): L3_gr_info_t = L3_gr_info_t(alloca(L3_gr_info_t.SIZE_BYTES).ptr)
	fun L3_gr_info_tAlloc(sfbtab: CPointer<UByte>, part_23_length: UShort, big_values: UShort, scalefac_compress: UShort, global_gain: UByte, block_type: UByte, mixed_block_flag: UByte, n_long_sfb: UByte, n_short_sfb: UByte, table_select: Array3UByte, region_count: Array3UByte, subblock_gain: Array3UByte, preflag: UByte, scalefac_scale: UByte, count1_table: UByte, scfsi: UByte): L3_gr_info_t = L3_gr_info_tAlloc().apply { this.sfbtab = sfbtab; this.part_23_length = part_23_length; this.big_values = big_values; this.scalefac_compress = scalefac_compress; this.global_gain = global_gain; this.block_type = block_type; this.mixed_block_flag = mixed_block_flag; this.n_long_sfb = n_long_sfb; this.n_short_sfb = n_short_sfb; this.table_select = table_select; this.region_count = region_count; this.subblock_gain = subblock_gain; this.preflag = preflag; this.scalefac_scale = scalefac_scale; this.count1_table = count1_table; this.scfsi = scfsi }
	fun L3_gr_info_t.copyFrom(src: L3_gr_info_t): L3_gr_info_t = this.apply { memcpy(CPointer<Unit>(this.ptr), CPointer<Unit>(src.ptr), L3_gr_info_t.SIZE_BYTES) }
	fun fixedArrayOfL3_gr_info_t(size: Int, vararg items: L3_gr_info_t): CPointer<L3_gr_info_t> = alloca_zero(size * L3_gr_info_t.SIZE_BYTES).toCPointer<L3_gr_info_t>().also { for (n in 0 until items.size) L3_gr_info_t(it.ptr + n * L3_gr_info_t.SIZE_BYTES).copyFrom(items[n]) }
	operator fun CPointer<L3_gr_info_t>.get(index: Int): L3_gr_info_t = L3_gr_info_t(this.ptr + index * L3_gr_info_t.SIZE_BYTES)
	operator fun CPointer<L3_gr_info_t>.set(index: Int, value: L3_gr_info_t) = L3_gr_info_t(this.ptr + index * L3_gr_info_t.SIZE_BYTES).copyFrom(value)
	@kotlin.jvm.JvmName("plusL3_gr_info_t") operator fun CPointer<L3_gr_info_t>.plus(offset: Int): CPointer<L3_gr_info_t> = CPointer(this.ptr + offset * L3_gr_info_t.SIZE_BYTES)
	@kotlin.jvm.JvmName("minusL3_gr_info_t") operator fun CPointer<L3_gr_info_t>.minus(offset: Int): CPointer<L3_gr_info_t> = CPointer(this.ptr - offset * L3_gr_info_t.SIZE_BYTES)
	@kotlin.jvm.JvmName("minusPtrL3_gr_info_t") operator fun CPointer<L3_gr_info_t>.minus(other: CPointer<L3_gr_info_t>) = (this.ptr - other.ptr) / L3_gr_info_t.SIZE_BYTES
	var CPointer<L3_gr_info_t>.value: L3_gr_info_t get() = this[0]; set(value) = run { this[0] = value }
	var L3_gr_info_t.sfbtab: CPointer<UByte> get() = CPointer(lw(ptr + L3_gr_info_t.OFFSET_sfbtab)); set(value) = run { sw(ptr + L3_gr_info_t.OFFSET_sfbtab, value.ptr) }
	var L3_gr_info_t.part_23_length: UShort get() = lh(ptr + L3_gr_info_t.OFFSET_part_23_length).toUShort(); set(value) = sh(ptr + L3_gr_info_t.OFFSET_part_23_length, (value).toShort())
	var L3_gr_info_t.big_values: UShort get() = lh(ptr + L3_gr_info_t.OFFSET_big_values).toUShort(); set(value) = sh(ptr + L3_gr_info_t.OFFSET_big_values, (value).toShort())
	var L3_gr_info_t.scalefac_compress: UShort get() = lh(ptr + L3_gr_info_t.OFFSET_scalefac_compress).toUShort(); set(value) = sh(ptr + L3_gr_info_t.OFFSET_scalefac_compress, (value).toShort())
	var L3_gr_info_t.global_gain: UByte get() = lb(ptr + L3_gr_info_t.OFFSET_global_gain).toUByte(); set(value) = sb(ptr + L3_gr_info_t.OFFSET_global_gain, (value).toByte())
	var L3_gr_info_t.block_type: UByte get() = lb(ptr + L3_gr_info_t.OFFSET_block_type).toUByte(); set(value) = sb(ptr + L3_gr_info_t.OFFSET_block_type, (value).toByte())
	var L3_gr_info_t.mixed_block_flag: UByte get() = lb(ptr + L3_gr_info_t.OFFSET_mixed_block_flag).toUByte(); set(value) = sb(ptr + L3_gr_info_t.OFFSET_mixed_block_flag, (value).toByte())
	var L3_gr_info_t.n_long_sfb: UByte get() = lb(ptr + L3_gr_info_t.OFFSET_n_long_sfb).toUByte(); set(value) = sb(ptr + L3_gr_info_t.OFFSET_n_long_sfb, (value).toByte())
	var L3_gr_info_t.n_short_sfb: UByte get() = lb(ptr + L3_gr_info_t.OFFSET_n_short_sfb).toUByte(); set(value) = sb(ptr + L3_gr_info_t.OFFSET_n_short_sfb, (value).toByte())
	var L3_gr_info_t.table_select: Array3UByte get() = Array3UByte(ptr + L3_gr_info_t.OFFSET_table_select); set(value) = run { TODO("Unsupported setting ftype=UByte[3]") }
	var L3_gr_info_t.region_count: Array3UByte get() = Array3UByte(ptr + L3_gr_info_t.OFFSET_region_count); set(value) = run { TODO("Unsupported setting ftype=UByte[3]") }
	var L3_gr_info_t.subblock_gain: Array3UByte get() = Array3UByte(ptr + L3_gr_info_t.OFFSET_subblock_gain); set(value) = run { TODO("Unsupported setting ftype=UByte[3]") }
	var L3_gr_info_t.preflag: UByte get() = lb(ptr + L3_gr_info_t.OFFSET_preflag).toUByte(); set(value) = sb(ptr + L3_gr_info_t.OFFSET_preflag, (value).toByte())
	var L3_gr_info_t.scalefac_scale: UByte get() = lb(ptr + L3_gr_info_t.OFFSET_scalefac_scale).toUByte(); set(value) = sb(ptr + L3_gr_info_t.OFFSET_scalefac_scale, (value).toByte())
	var L3_gr_info_t.count1_table: UByte get() = lb(ptr + L3_gr_info_t.OFFSET_count1_table).toUByte(); set(value) = sb(ptr + L3_gr_info_t.OFFSET_count1_table, (value).toByte())
	var L3_gr_info_t.scfsi: UByte get() = lb(ptr + L3_gr_info_t.OFFSET_scfsi).toUByte(); set(value) = sb(ptr + L3_gr_info_t.OFFSET_scfsi, (value).toByte())
	/*!inline*/ class mp3dec_scratch_t(val ptr: Int) : IStruct {
		companion object : IStructCompanion<mp3dec_scratch_t>  {
			const val SIZE_BYTES = 16233
			override val SIZE = SIZE_BYTES
			const val OFFSET_bs = 0
			const val OFFSET_maindata = 12
			const val OFFSET_gr_info = 2827
			const val OFFSET_grbuf = 2939
			const val OFFSET_scf = 7547
			const val OFFSET_syn = 7707
			const val OFFSET_ist_pos = 16155
		}
	}
	fun mp3dec_scratch_tAlloc(): mp3dec_scratch_t = mp3dec_scratch_t(alloca(mp3dec_scratch_t.SIZE_BYTES).ptr)
	fun mp3dec_scratch_tAlloc(bs: bs_t, maindata: Array2815UByte, gr_info: Array4L3_gr_info_t, grbuf: Array2Array576Float, scf: Array40Float, syn: Array33Array64Float, ist_pos: Array2Array39UByte): mp3dec_scratch_t = mp3dec_scratch_tAlloc().apply { this.bs = bs; this.maindata = maindata; this.gr_info = gr_info; this.grbuf = grbuf; this.scf = scf; this.syn = syn; this.ist_pos = ist_pos }
	fun mp3dec_scratch_t.copyFrom(src: mp3dec_scratch_t): mp3dec_scratch_t = this.apply { memcpy(CPointer<Unit>(this.ptr), CPointer<Unit>(src.ptr), mp3dec_scratch_t.SIZE_BYTES) }
	fun fixedArrayOfmp3dec_scratch_t(size: Int, vararg items: mp3dec_scratch_t): CPointer<mp3dec_scratch_t> = alloca_zero(size * mp3dec_scratch_t.SIZE_BYTES).toCPointer<mp3dec_scratch_t>().also { for (n in 0 until items.size) mp3dec_scratch_t(it.ptr + n * mp3dec_scratch_t.SIZE_BYTES).copyFrom(items[n]) }
	operator fun CPointer<mp3dec_scratch_t>.get(index: Int): mp3dec_scratch_t = mp3dec_scratch_t(this.ptr + index * mp3dec_scratch_t.SIZE_BYTES)
	operator fun CPointer<mp3dec_scratch_t>.set(index: Int, value: mp3dec_scratch_t) = mp3dec_scratch_t(this.ptr + index * mp3dec_scratch_t.SIZE_BYTES).copyFrom(value)
	@kotlin.jvm.JvmName("plusmp3dec_scratch_t") operator fun CPointer<mp3dec_scratch_t>.plus(offset: Int): CPointer<mp3dec_scratch_t> = CPointer(this.ptr + offset * mp3dec_scratch_t.SIZE_BYTES)
	@kotlin.jvm.JvmName("minusmp3dec_scratch_t") operator fun CPointer<mp3dec_scratch_t>.minus(offset: Int): CPointer<mp3dec_scratch_t> = CPointer(this.ptr - offset * mp3dec_scratch_t.SIZE_BYTES)
	@kotlin.jvm.JvmName("minusPtrmp3dec_scratch_t") operator fun CPointer<mp3dec_scratch_t>.minus(other: CPointer<mp3dec_scratch_t>) = (this.ptr - other.ptr) / mp3dec_scratch_t.SIZE_BYTES
	var CPointer<mp3dec_scratch_t>.value: mp3dec_scratch_t get() = this[0]; set(value) = run { this[0] = value }
	var mp3dec_scratch_t.bs: bs_t get() = bs_t(ptr + mp3dec_scratch_t.OFFSET_bs); set(value) = run { bs_t(ptr + mp3dec_scratch_t.OFFSET_bs).copyFrom(value) }
	var mp3dec_scratch_t.maindata: Array2815UByte get() = Array2815UByte(ptr + mp3dec_scratch_t.OFFSET_maindata); set(value) = run { TODO("Unsupported setting ftype=UByte[2815]") }
	var mp3dec_scratch_t.gr_info: Array4L3_gr_info_t get() = Array4L3_gr_info_t(ptr + mp3dec_scratch_t.OFFSET_gr_info); set(value) = run { TODO("Unsupported setting ftype=struct null[4]") }
	var mp3dec_scratch_t.grbuf: Array2Array576Float get() = Array2Array576Float(ptr + mp3dec_scratch_t.OFFSET_grbuf); set(value) = run { TODO("Unsupported setting ftype=Float[576][2]") }
	var mp3dec_scratch_t.scf: Array40Float get() = Array40Float(ptr + mp3dec_scratch_t.OFFSET_scf); set(value) = run { TODO("Unsupported setting ftype=Float[40]") }
	var mp3dec_scratch_t.syn: Array33Array64Float get() = Array33Array64Float(ptr + mp3dec_scratch_t.OFFSET_syn); set(value) = run { TODO("Unsupported setting ftype=Float[64][33]") }
	var mp3dec_scratch_t.ist_pos: Array2Array39UByte get() = Array2Array39UByte(ptr + mp3dec_scratch_t.OFFSET_ist_pos); set(value) = run { TODO("Unsupported setting ftype=UByte[39][2]") }
	/*!inline*/ class Array192Float(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 192
			const val ELEMENT_SIZE_BYTES = 4
			const val TOTAL_SIZE_BYTES = /*768*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array192Float.get(index: Int): Float = Float.fromBits(lw(addr(index)))
	operator fun Array192Float.set(index: Int, value: Float): Unit = run { sw(addr(index), (value).toBits()) }
	var Array192Float.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array192FloatAlloc(vararg items: Float): Array192Float = Array192Float(alloca_zero(Array192Float.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array192Float.plus(offset: Int): CPointer<Float> = CPointer<Float>(addr(offset))
	operator fun Array192Float.minus(offset: Int): CPointer<Float> = CPointer<Float>(addr(-offset))
	/*!inline*/ class Array64UByte(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 64
			const val ELEMENT_SIZE_BYTES = 1
			const val TOTAL_SIZE_BYTES = /*64*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array64UByte.get(index: Int): UByte = lb(addr(index)).toUByte()
	operator fun Array64UByte.set(index: Int, value: UByte): Unit = run { sb(addr(index), (value).toByte()) }
	var Array64UByte.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array64UByteAlloc(vararg items: UByte): Array64UByte = Array64UByte(alloca_zero(Array64UByte.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array64UByte.plus(offset: Int): CPointer<UByte> = CPointer<UByte>(addr(offset))
	operator fun Array64UByte.minus(offset: Int): CPointer<UByte> = CPointer<UByte>(addr(-offset))
	/*!inline*/ class Array3UByte(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 3
			const val ELEMENT_SIZE_BYTES = 1
			const val TOTAL_SIZE_BYTES = /*3*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array3UByte.get(index: Int): UByte = lb(addr(index)).toUByte()
	operator fun Array3UByte.set(index: Int, value: UByte): Unit = run { sb(addr(index), (value).toByte()) }
	var Array3UByte.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array3UByteAlloc(vararg items: UByte): Array3UByte = Array3UByte(alloca_zero(Array3UByte.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array3UByte.plus(offset: Int): CPointer<UByte> = CPointer<UByte>(addr(offset))
	operator fun Array3UByte.minus(offset: Int): CPointer<UByte> = CPointer<UByte>(addr(-offset))
	/*!inline*/ class Array2815UByte(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 2815
			const val ELEMENT_SIZE_BYTES = 1
			const val TOTAL_SIZE_BYTES = /*2815*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array2815UByte.get(index: Int): UByte = lb(addr(index)).toUByte()
	operator fun Array2815UByte.set(index: Int, value: UByte): Unit = run { sb(addr(index), (value).toByte()) }
	var Array2815UByte.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array2815UByteAlloc(vararg items: UByte): Array2815UByte = Array2815UByte(alloca_zero(Array2815UByte.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array2815UByte.plus(offset: Int): CPointer<UByte> = CPointer<UByte>(addr(offset))
	operator fun Array2815UByte.minus(offset: Int): CPointer<UByte> = CPointer<UByte>(addr(-offset))
	/*!inline*/ class Array4L3_gr_info_t(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 4
			const val ELEMENT_SIZE_BYTES = 28
			const val TOTAL_SIZE_BYTES = /*112*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array4L3_gr_info_t.get(index: Int): L3_gr_info_t = L3_gr_info_t(addr(index))
	operator fun Array4L3_gr_info_t.set(index: Int, value: L3_gr_info_t): Unit = run { L3_gr_info_t(addr(index)).copyFrom(value) }
	var Array4L3_gr_info_t.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array4L3_gr_info_tAlloc(vararg items: L3_gr_info_t): Array4L3_gr_info_t = Array4L3_gr_info_t(alloca_zero(Array4L3_gr_info_t.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array4L3_gr_info_t.plus(offset: Int): CPointer<L3_gr_info_t> = CPointer<L3_gr_info_t>(addr(offset))
	operator fun Array4L3_gr_info_t.minus(offset: Int): CPointer<L3_gr_info_t> = CPointer<L3_gr_info_t>(addr(-offset))
	/*!inline*/ class Array2Array576Float(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 2
			const val ELEMENT_SIZE_BYTES = 2304
			const val TOTAL_SIZE_BYTES = /*4608*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array2Array576Float.get(index: Int): Array576Float = Array576Float(addr(index))
	operator fun Array2Array576Float.set(index: Int, value: Array576Float): Unit = run { memcpy(CPointer(addr(index)), CPointer(value.ptr), Array2Array576Float.ELEMENT_SIZE_BYTES) }
	var Array2Array576Float.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array2Array576FloatAlloc(vararg items: Array576Float): Array2Array576Float = Array2Array576Float(alloca_zero(Array2Array576Float.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array2Array576Float.plus(offset: Int): CPointer<Array576Float> = CPointer<Array576Float>(addr(offset))
	operator fun Array2Array576Float.minus(offset: Int): CPointer<Array576Float> = CPointer<Array576Float>(addr(-offset))
	/*!inline*/ class Array576Float(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 576
			const val ELEMENT_SIZE_BYTES = 4
			const val TOTAL_SIZE_BYTES = /*2304*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array576Float.get(index: Int): Float = Float.fromBits(lw(addr(index)))
	operator fun Array576Float.set(index: Int, value: Float): Unit = run { sw(addr(index), (value).toBits()) }
	var Array576Float.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array576FloatAlloc(vararg items: Float): Array576Float = Array576Float(alloca_zero(Array576Float.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array576Float.plus(offset: Int): CPointer<Float> = CPointer<Float>(addr(offset))
	operator fun Array576Float.minus(offset: Int): CPointer<Float> = CPointer<Float>(addr(-offset))
	/*!inline*/ class Array40Float(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 40
			const val ELEMENT_SIZE_BYTES = 4
			const val TOTAL_SIZE_BYTES = /*160*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array40Float.get(index: Int): Float = Float.fromBits(lw(addr(index)))
	operator fun Array40Float.set(index: Int, value: Float): Unit = run { sw(addr(index), (value).toBits()) }
	var Array40Float.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array40FloatAlloc(vararg items: Float): Array40Float = Array40Float(alloca_zero(Array40Float.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array40Float.plus(offset: Int): CPointer<Float> = CPointer<Float>(addr(offset))
	operator fun Array40Float.minus(offset: Int): CPointer<Float> = CPointer<Float>(addr(-offset))
	/*!inline*/ class Array33Array64Float(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 33
			const val ELEMENT_SIZE_BYTES = 256
			const val TOTAL_SIZE_BYTES = /*8448*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array33Array64Float.get(index: Int): Array64Float = Array64Float(addr(index))
	operator fun Array33Array64Float.set(index: Int, value: Array64Float): Unit = run { memcpy(CPointer(addr(index)), CPointer(value.ptr), Array33Array64Float.ELEMENT_SIZE_BYTES) }
	var Array33Array64Float.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array33Array64FloatAlloc(vararg items: Array64Float): Array33Array64Float = Array33Array64Float(alloca_zero(Array33Array64Float.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array33Array64Float.plus(offset: Int): CPointer<Array64Float> = CPointer<Array64Float>(addr(offset))
	operator fun Array33Array64Float.minus(offset: Int): CPointer<Array64Float> = CPointer<Array64Float>(addr(-offset))
	/*!inline*/ class Array64Float(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 64
			const val ELEMENT_SIZE_BYTES = 4
			const val TOTAL_SIZE_BYTES = /*256*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array64Float.get(index: Int): Float = Float.fromBits(lw(addr(index)))
	operator fun Array64Float.set(index: Int, value: Float): Unit = run { sw(addr(index), (value).toBits()) }
	var Array64Float.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array64FloatAlloc(vararg items: Float): Array64Float = Array64Float(alloca_zero(Array64Float.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array64Float.plus(offset: Int): CPointer<Float> = CPointer<Float>(addr(offset))
	operator fun Array64Float.minus(offset: Int): CPointer<Float> = CPointer<Float>(addr(-offset))
	/*!inline*/ class Array2Array39UByte(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 2
			const val ELEMENT_SIZE_BYTES = 39
			const val TOTAL_SIZE_BYTES = /*78*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array2Array39UByte.get(index: Int): Array39UByte = Array39UByte(addr(index))
	operator fun Array2Array39UByte.set(index: Int, value: Array39UByte): Unit = run { memcpy(CPointer(addr(index)), CPointer(value.ptr), Array2Array39UByte.ELEMENT_SIZE_BYTES) }
	var Array2Array39UByte.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array2Array39UByteAlloc(vararg items: Array39UByte): Array2Array39UByte = Array2Array39UByte(alloca_zero(Array2Array39UByte.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array2Array39UByte.plus(offset: Int): CPointer<Array39UByte> = CPointer<Array39UByte>(addr(offset))
	operator fun Array2Array39UByte.minus(offset: Int): CPointer<Array39UByte> = CPointer<Array39UByte>(addr(-offset))
	/*!inline*/ class Array39UByte(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 39
			const val ELEMENT_SIZE_BYTES = 1
			const val TOTAL_SIZE_BYTES = /*39*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array39UByte.get(index: Int): UByte = lb(addr(index)).toUByte()
	operator fun Array39UByte.set(index: Int, value: UByte): Unit = run { sb(addr(index), (value).toByte()) }
	var Array39UByte.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array39UByteAlloc(vararg items: UByte): Array39UByte = Array39UByte(alloca_zero(Array39UByte.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array39UByte.plus(offset: Int): CPointer<UByte> = CPointer<UByte>(addr(offset))
	operator fun Array39UByte.minus(offset: Int): CPointer<UByte> = CPointer<UByte>(addr(-offset))
}
