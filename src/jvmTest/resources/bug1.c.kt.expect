//ENTRY Program
//Program.main(arrayOf())
@Suppress("MemberVisibilityCanBePrivate", "FunctionName", "CanBeVal", "DoubleNegation", "LocalVariableName", "NAME_SHADOWING", "VARIABLE_WITH_REDUNDANT_INITIALIZER", "RemoveRedundantCallsOfConversionMethods", "EXPERIMENTAL_IS_NOT_ENABLED", "RedundantExplicitType", "RemoveExplicitTypeArguments", "RedundantExplicitType", "unused", "UNCHECKED_CAST", "UNUSED_VARIABLE", "UNUSED_PARAMETER", "NOTHING_TO_INLINE", "PropertyName", "ClassName", "USELESS_CAST", "PrivatePropertyName", "CanBeParameter", "UnusedMainParameter")
@UseExperimental(ExperimentalUnsignedTypes::class)
class Program(HEAP_SIZE: Int = 0) : Runtime(HEAP_SIZE) {
	private var __STATIC_L12_read_scalefactors_g_deq_L12: Array54Float = { Array54FloatAlloc((9.53674316E-7f / (3.toFloat())), (7.56931807E-7f / (3.toFloat())), (6.00777173E-7f / (3.toFloat())), (9.53674316E-7f / (7.toFloat())), (7.56931807E-7f / (7.toFloat())), (6.00777173E-7f / (7.toFloat())), (9.53674316E-7f / (15.toFloat())), (7.56931807E-7f / (15.toFloat())), (6.00777173E-7f / (15.toFloat())), (9.53674316E-7f / (31.toFloat())), (7.56931807E-7f / (31.toFloat())), (6.00777173E-7f / (31.toFloat())), (9.53674316E-7f / (63.toFloat())), (7.56931807E-7f / (63.toFloat())), (6.00777173E-7f / (63.toFloat())), (9.53674316E-7f / (127.toFloat())), (7.56931807E-7f / (127.toFloat())), (6.00777173E-7f / (127.toFloat())), (9.53674316E-7f / (255.toFloat())), (7.56931807E-7f / (255.toFloat())), (6.00777173E-7f / (255.toFloat())), (9.53674316E-7f / (511.toFloat())), (7.56931807E-7f / (511.toFloat())), (6.00777173E-7f / (511.toFloat())), (9.53674316E-7f / (1023.toFloat())), (7.56931807E-7f / (1023.toFloat())), (6.00777173E-7f / (1023.toFloat())), (9.53674316E-7f / (2047.toFloat())), (7.56931807E-7f / (2047.toFloat())), (6.00777173E-7f / (2047.toFloat())), (9.53674316E-7f / (4095.toFloat())), (7.56931807E-7f / (4095.toFloat())), (6.00777173E-7f / (4095.toFloat())), (9.53674316E-7f / (8191.toFloat())), (7.56931807E-7f / (8191.toFloat())), (6.00777173E-7f / (8191.toFloat())), (9.53674316E-7f / (16383.toFloat())), (7.56931807E-7f / (16383.toFloat())), (6.00777173E-7f / (16383.toFloat())), (9.53674316E-7f / (32767.toFloat())), (7.56931807E-7f / (32767.toFloat())), (6.00777173E-7f / (32767.toFloat())), (9.53674316E-7f / (65535.toFloat())), (7.56931807E-7f / (65535.toFloat())), (6.00777173E-7f / (65535.toFloat())), (9.53674316E-7f / (3.toFloat())), (7.56931807E-7f / (3.toFloat())), (6.00777173E-7f / (3.toFloat())), (9.53674316E-7f / (5.toFloat())), (7.56931807E-7f / (5.toFloat())), (6.00777173E-7f / (5.toFloat())), (9.53674316E-7f / (9.toFloat())), (7.56931807E-7f / (9.toFloat())), (6.00777173E-7f / (9.toFloat()))) }()
	// typealias uint8_t = UByte
	// typealias uint16_t = UShort
	// typealias uint32_t = UInt
	// typealias int8_t = Byte
	// typealias int16_t = Short
	// typealias int32_t = Int
	// typealias bs_t = bs_t
	// typealias L12_scale_info = L12_scale_info
	fun L12_read_scalefactors(bs: CPointer<bs_t>, pba: CPointer<UByte>, scfcod: CPointer<UByte>, bands: Int, scf: CPointer<Float>): Unit = stackFrame {
		var pba = pba // Mutating parameter
		var scf = scf // Mutating parameter
		var g_deq_L12: Array54Float = __STATIC_L12_read_scalefactors_g_deq_L12
		var i: Int = 0
		var m: Int = 0
		i = 0
		while (i < bands) {
			stackFrame {
				var s: Float = (0.toFloat())
				var ba: Int = (pba.also { pba += 1 }.value.toInt())
				var mask: Int = (if (ba.toBool()) (4 + ((19 shr ((scfcod[i].toInt())).toInt()) and 3)) else 0)
				m = 4
				while (m.toBool()) {
					if ((mask and m).toBool()) {
						stackFrame {
							var b: Int = (get_bits(bs, 6).toInt())
							s = g_deq_L12[((ba * 3) - 6) + (b % 3)] * (((1 shl (21).toInt()) shr ((b / 3)).toInt()).toFloat())
						}
					}
					scf.also { scf += 1 }.value = s
					m = m shr (1).toInt()
				}
			}
			i += 1
		}
	}
	fun L12_read_scale_info(hdr: CPointer<UByte>, bs: CPointer<bs_t>, sci: CPointer<L12_scale_info>): Unit = stackFrame {
	}
	
	//////////////////
	// C STRUCTURES //
	//////////////////
	
	/*!inline*/ class bs_t(val ptr: Int) : IStruct {
		companion object : IStructCompanion<bs_t>  {
			const val SIZE_BYTES = 12
			override val SIZE = SIZE_BYTES
			const val OFFSET_buf = 0
			const val OFFSET_pos = 4
			const val OFFSET_limit = 8
		}
	}
	fun bs_tAlloc(): bs_t = bs_t(alloca(bs_t.SIZE_BYTES).ptr)
	fun bs_tAlloc(buf: CPointer<UByte>, pos: Int, limit: Int): bs_t = bs_tAlloc().apply { this.buf = buf; this.pos = pos; this.limit = limit }
	fun bs_t.copyFrom(src: bs_t): bs_t = this.apply { memcpy(CPointer<Unit>(this.ptr), CPointer<Unit>(src.ptr), bs_t.SIZE_BYTES) }
	fun fixedArrayOfbs_t(size: Int, vararg items: bs_t): CPointer<bs_t> = alloca_zero(size * bs_t.SIZE_BYTES).toCPointer<bs_t>().also { for (n in 0 until items.size) bs_t(it.ptr + n * bs_t.SIZE_BYTES).copyFrom(items[n]) }
	operator fun CPointer<bs_t>.get(index: Int): bs_t = bs_t(this.ptr + index * bs_t.SIZE_BYTES)
	operator fun CPointer<bs_t>.set(index: Int, value: bs_t) = bs_t(this.ptr + index * bs_t.SIZE_BYTES).copyFrom(value)
	@JvmName("plusbs_t") operator fun CPointer<bs_t>.plus(offset: Int): CPointer<bs_t> = CPointer(this.ptr + offset * bs_t.SIZE_BYTES)
	@JvmName("minusbs_t") operator fun CPointer<bs_t>.minus(offset: Int): CPointer<bs_t> = CPointer(this.ptr - offset * bs_t.SIZE_BYTES)
	@JvmName("minusPtrbs_t") operator fun CPointer<bs_t>.minus(other: CPointer<bs_t>) = (this.ptr - other.ptr) / bs_t.SIZE_BYTES
	var CPointer<bs_t>.value: bs_t get() = this[0]; set(value) = run { this[0] = value }
	var bs_t.buf: CPointer<UByte> get() = CPointer(lw(ptr + bs_t.OFFSET_buf)); set(value) = run { sw(ptr + bs_t.OFFSET_buf, value.ptr) }
	var bs_t.pos: Int get() = lw(ptr + bs_t.OFFSET_pos); set(value) = sw(ptr + bs_t.OFFSET_pos, value)
	var bs_t.limit: Int get() = lw(ptr + bs_t.OFFSET_limit); set(value) = sw(ptr + bs_t.OFFSET_limit, value)
	/*!inline*/ class L12_scale_info(val ptr: Int) : IStruct {
		companion object : IStructCompanion<L12_scale_info>  {
			const val SIZE_BYTES = 898
			override val SIZE = SIZE_BYTES
			const val OFFSET_scf = 0
			const val OFFSET_total_bands = 768
			const val OFFSET_stereo_bands = 769
			const val OFFSET_bitalloc = 770
			const val OFFSET_scfcod = 834
		}
	}
	fun L12_scale_infoAlloc(): L12_scale_info = L12_scale_info(alloca(L12_scale_info.SIZE_BYTES).ptr)
	fun L12_scale_infoAlloc(scf: Array192Float, total_bands: UByte, stereo_bands: UByte, bitalloc: Array64UByte, scfcod: Array64UByte): L12_scale_info = L12_scale_infoAlloc().apply { this.scf = scf; this.total_bands = total_bands; this.stereo_bands = stereo_bands; this.bitalloc = bitalloc; this.scfcod = scfcod }
	fun L12_scale_info.copyFrom(src: L12_scale_info): L12_scale_info = this.apply { memcpy(CPointer<Unit>(this.ptr), CPointer<Unit>(src.ptr), L12_scale_info.SIZE_BYTES) }
	fun fixedArrayOfL12_scale_info(size: Int, vararg items: L12_scale_info): CPointer<L12_scale_info> = alloca_zero(size * L12_scale_info.SIZE_BYTES).toCPointer<L12_scale_info>().also { for (n in 0 until items.size) L12_scale_info(it.ptr + n * L12_scale_info.SIZE_BYTES).copyFrom(items[n]) }
	operator fun CPointer<L12_scale_info>.get(index: Int): L12_scale_info = L12_scale_info(this.ptr + index * L12_scale_info.SIZE_BYTES)
	operator fun CPointer<L12_scale_info>.set(index: Int, value: L12_scale_info) = L12_scale_info(this.ptr + index * L12_scale_info.SIZE_BYTES).copyFrom(value)
	@JvmName("plusL12_scale_info") operator fun CPointer<L12_scale_info>.plus(offset: Int): CPointer<L12_scale_info> = CPointer(this.ptr + offset * L12_scale_info.SIZE_BYTES)
	@JvmName("minusL12_scale_info") operator fun CPointer<L12_scale_info>.minus(offset: Int): CPointer<L12_scale_info> = CPointer(this.ptr - offset * L12_scale_info.SIZE_BYTES)
	@JvmName("minusPtrL12_scale_info") operator fun CPointer<L12_scale_info>.minus(other: CPointer<L12_scale_info>) = (this.ptr - other.ptr) / L12_scale_info.SIZE_BYTES
	var CPointer<L12_scale_info>.value: L12_scale_info get() = this[0]; set(value) = run { this[0] = value }
	var L12_scale_info.scf: Array192Float get() = Array192Float(ptr + L12_scale_info.OFFSET_scf); set(value) = run { TODO("Unsupported setting ftype=Float[192]") }
	var L12_scale_info.total_bands: UByte get() = lb(ptr + L12_scale_info.OFFSET_total_bands).toUByte(); set(value) = sb(ptr + L12_scale_info.OFFSET_total_bands, (value).toByte())
	var L12_scale_info.stereo_bands: UByte get() = lb(ptr + L12_scale_info.OFFSET_stereo_bands).toUByte(); set(value) = sb(ptr + L12_scale_info.OFFSET_stereo_bands, (value).toByte())
	var L12_scale_info.bitalloc: Array64UByte get() = Array64UByte(ptr + L12_scale_info.OFFSET_bitalloc); set(value) = run { TODO("Unsupported setting ftype=UByte[64]") }
	var L12_scale_info.scfcod: Array64UByte get() = Array64UByte(ptr + L12_scale_info.OFFSET_scfcod); set(value) = run { TODO("Unsupported setting ftype=UByte[64]") }
	/*!inline*/ class Array192Float(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 192
			const val ELEMENT_SIZE_BYTES = 4
			const val TOTAL_SIZE_BYTES = /*768*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array192Float.get(index: Int): Float = Float.fromBits(lw(addr(index)))
	operator fun Array192Float.set(index: Int, value: Float): Unit = run { sw(addr(index), (value).toBits()) }
	var Array192Float.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array192FloatAlloc(vararg items: Float): Array192Float = Array192Float(alloca_zero(Array192Float.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array192Float.plus(offset: Int): CPointer<Float> = CPointer<Float>(addr(offset))
	operator fun Array192Float.minus(offset: Int): CPointer<Float> = CPointer<Float>(addr(-offset))
	/*!inline*/ class Array64UByte(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 64
			const val ELEMENT_SIZE_BYTES = 1
			const val TOTAL_SIZE_BYTES = /*64*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array64UByte.get(index: Int): UByte = lb(addr(index)).toUByte()
	operator fun Array64UByte.set(index: Int, value: UByte): Unit = run { sb(addr(index), (value).toByte()) }
	var Array64UByte.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array64UByteAlloc(vararg items: UByte): Array64UByte = Array64UByte(alloca_zero(Array64UByte.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array64UByte.plus(offset: Int): CPointer<UByte> = CPointer<UByte>(addr(offset))
	operator fun Array64UByte.minus(offset: Int): CPointer<UByte> = CPointer<UByte>(addr(-offset))
	/*!inline*/ class Array54Float(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 54
			const val ELEMENT_SIZE_BYTES = 4
			const val TOTAL_SIZE_BYTES = /*216*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array54Float.get(index: Int): Float = Float.fromBits(lw(addr(index)))
	operator fun Array54Float.set(index: Int, value: Float): Unit = run { sw(addr(index), (value).toBits()) }
	var Array54Float.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array54FloatAlloc(vararg items: Float): Array54Float = Array54Float(alloca_zero(Array54Float.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array54Float.plus(offset: Int): CPointer<Float> = CPointer<Float>(addr(offset))
	operator fun Array54Float.minus(offset: Int): CPointer<Float> = CPointer<Float>(addr(-offset))
}
