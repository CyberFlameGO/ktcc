//ENTRY Program
//Program.main(arrayOf())
@Suppress("MemberVisibilityCanBePrivate", "FunctionName", "CanBeVal", "DoubleNegation", "LocalVariableName", "NAME_SHADOWING", "VARIABLE_WITH_REDUNDANT_INITIALIZER", "RemoveRedundantCallsOfConversionMethods", "EXPERIMENTAL_IS_NOT_ENABLED", "RedundantExplicitType", "RemoveExplicitTypeArguments", "RedundantExplicitType", "unused", "UNCHECKED_CAST", "UNUSED_VARIABLE", "UNUSED_PARAMETER", "NOTHING_TO_INLINE", "PropertyName", "ClassName", "USELESS_CAST", "PrivatePropertyName", "CanBeParameter", "UnusedMainParameter")
@UseExperimental(ExperimentalUnsignedTypes::class)
class Program(HEAP_SIZE: Int = 0) : Runtime(HEAP_SIZE) {
	fun L3_imdct_short(grbuf: CPointer<Float>, overlap: CPointer<Float>, nbands: Int): Unit = stackFrame {
		var grbuf = grbuf // Mutating parameter
		var overlap = overlap // Mutating parameter
		var nbands = nbands // Mutating parameter
		while (nbands > 0) {
			stackFrame {
				var tmp: Array18Float = Array18FloatAlloc((0.toFloat()))
				__builtin___memcpy_chk(tmp, grbuf, 72, __builtin_object_size(tmp, 0))
				__builtin___memcpy_chk(grbuf, overlap, (6 * Float.SIZE_BYTES), __builtin_object_size(grbuf, 0))
				L3_imdct12(tmp, (grbuf + 6), (overlap + 6))
				L3_imdct12((tmp + 1), (grbuf + 12), (overlap + 6))
				L3_imdct12((tmp + 2), overlap, (overlap + 6))
			}
			run { nbands--; run { overlap + 9 }.also { `$` -> overlap = `$` }; run { grbuf + 18 }.also { `$` -> grbuf = `$` } }
		}
	}
	/*!inline*/ class Array18Float(val ptr: Int) {
		companion object {
			const val NUM_ELEMENTS = 18
			const val ELEMENT_SIZE_BYTES = 4
			const val TOTAL_SIZE_BYTES = /*72*/ (NUM_ELEMENTS * ELEMENT_SIZE_BYTES)
		}
		fun addr(index: Int) = ptr + index * ELEMENT_SIZE_BYTES
	}
	operator fun Array18Float.get(index: Int): Float = Float.fromBits(lw(addr(index)))
	operator fun Array18Float.set(index: Int, value: Float): Unit = run { sw(addr(index), (value).toBits()) }
	var Array18Float.value get() = this[0]; set(value) = run { this[0] = value }
	fun Array18FloatAlloc(vararg items: Float): Array18Float = Array18Float(alloca_zero(Array18Float.TOTAL_SIZE_BYTES).ptr).also { for (n in 0 until items.size) it[n] = items[n] }
	operator fun Array18Float.plus(offset: Int): CPointer<Float> = CPointer<Float>(addr(offset))
	operator fun Array18Float.minus(offset: Int): CPointer<Float> = CPointer<Float>(addr(-offset))
}
